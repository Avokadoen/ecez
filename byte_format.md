# ECEZ byte format - .ezby VERSION 0.4.0

Ecez support a custom byte format called ezby. This format define different [chunks](#chunk_sec) that contain structured bytes. This is inspired by the fantastic .vox format which is made by [ephtracy](https://github.com/ephtracy). 

## <a name="chunk_sec"></a>Chunks

This section contain each chunk defined by ezby and how they can be parsed.

### <a name="EZBY"></a> EZBY - File header metadata 

| <div style="width:155px">Data</div> | Bytes | <div style="width:300px">Description</div> |
|:------------------------------------|:-----:|:-------------------------------------------|
| "EZBY"                              | 4     | chunk identifier                           |
| *ezby major version*                | 1     | ezby major version of the current file     |
| *ezby minor version*                | 1     | ezby minor version of the current file     |
| *reserved*                          | 2     | reserved bytes                             |
| *number of entities*                | 8     | How many entities in this file             |

### <a name="COMP"></a>  COMP - Metadata for each component type 

The hashes has be generated by Fnv1a_64

TODO: mention alignment restrictions

| <div style="width:155px">Data</div> | Bytes | <div style="width:300px">Description</div>             |
|:------------------------------------|:-----:|:------------------------------------------------------ |
| "COMP"                              | 4     | chunk identifier                                       |
| *number of<br>components*           | 4     | how many compoents that are stored in<br>the chunk (N) |
| *component_hash*                    | 8 * N | Component type hash identifier. The<br>component data is sorted on the hashes<br>. Smallest to biggest.|
| *component_size*                    | 4 * N | Component byte size                                    |
| *component_log2_align*              | N     | Component log2 alignment                               |

### <a name="SHAR"></a>  SHAR - SharedState chunk (TODO)


### <a name="ARCH"></a>  ARCH - All entities and component data for an archetype

TODO: mention alignment restrictions

| <div style="width:155px">Data</div>                                         |     Bytes        | <div style="width:300px">Description</div>             |
|:----------------------------------------------------------------------------|:----------------:|:-------------------------------------------------------|
| "ARCH"                                                                      | 4                | chunk identifier                                       |
| *number of component<br>types*                                              | 4                | How many lists of component bytes (N)                  |
| *number of entities*                                                        | 8                | How many entities in this archetype (M)                |
| *N component type indices*                                                  | 4 * N            | A list of indices to component RTTI defined by the COMP chunk |
| *M entites*                                                                 | 8 * M            | A list of entities, the order reflect how they are stored in the actual archetype |
| *N list of component bytes*                                                 | $\sum_{i=0}^N M*sizeOf(i)$ | N individual lists of component bytes         |


### Chunk order

Each chunk must appear in a strict order. The order is:

 1. [EZBY](#EZBY)
 2. [COMP](#COMP)
 3. [ARCH](#ARCH)
     1. [ARCH](#ARCH) (optional, recursive)
 4. EOF

## <a name="data_types"></a>Data types

TODO: some data types

